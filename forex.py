# -*- coding: utf-8 -*-
"""forex.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1PMP3zKugIirn35Ce-sdPOR-hL9aiLjid
"""

#import library

from google.colab import files
import tensorflow as tf  
import pandas as pd
import numpy as np
from numpy import array
import matplotlib.pyplot as plt
from sklearn.preprocessing import MinMaxScaler
from tensorflow.keras.callbacks import EarlyStopping
from tensorflow.keras.callbacks import ModelCheckpoint
from tensorflow.keras.models import Sequential
from tensorflow.keras.layers import Dense, Dropout
from tensorflow.keras.layers import LSTM
from sklearn.metrics import mean_squared_error
import random as python_random
import datetime

#reading dataset
data = pd.read_csv('EURUSD1hour.csv')
data.drop([0], inplace = True)
data.head()

data['datetime'] = data['date'] + data['time']

data['shift_close'] = data['close'].shift(-1)

data.drop(data.loc[data['date']=='2020.10.20'].index, inplace=True)

data

#convert data to numpy array

arr_close = data['close'].to_numpy()
arr_date = data['datetime'].to_numpy()

arr_shiftclose = data['shift_close'].to_numpy()

#normalize data using min-max scaler

scaler = MinMaxScaler()
scaled_dataX = scaler.fit_transform(arr_close.reshape(-1,1))
scaled_dataY = scaler.fit_transform(arr_shiftclose.reshape(-1,1))
print(scaled_dataX)
print(scaled_dataY)

#split train and test data

train_x = scaled_dataX[0:59913,:]
test_x = scaled_dataX[59914:,:]

train_y = scaled_dataY[0:59913,:]
test_y = scaled_dataY[59914:,:]

#split train and test date data
#trainDateSize = int(len(arr_date)*0.8)
train_date = arr_date[0:59913]
test_date = arr_date[59914:]

#reshape input to be [samples, time steps, features]

trainX = np.reshape(train_x, (train_x.shape[0], train_x.shape[1], 1))
testX = np.reshape(test_x, (test_x.shape[0], test_x.shape[1], 1))

print(trainX)
print(testX)

#to not get random result

# The below is necessary for starting Numpy generated random numbers
# in a well-defined initial state.
np.random.seed(123)

# The below is necessary for starting core Python generated random numbers
# in a well-defined state.
python_random.seed(123)

# The below set_seed() will make random number generation
# in the TensorFlow backend have a well-defined initial state.
# For further details, see:
# https://www.tensorflow.org/api_docs/python/tf/random/set_seed
tf.random.set_seed(1234)

#Create LSTM
t_steps = 1
n_feature = 1
model = Sequential()
#model.add(LSTM(10, input_shape=(t_steps, n_feature), return_sequences=True))
#model.add(LSTM(10, input_shape=(t_steps, n_feature), return_sequences=True))
model.add(LSTM(5, input_shape=(t_steps, n_feature), return_sequences=False))
#model.add(Dropout(0.1))
model.add(Dense(1))
model.compile(loss='mean_squared_error', optimizer='adam')

earlyStop = EarlyStopping(monitor='val_loss', mode='min', verbose=1, patience=30)
#mCheckpoint = ModelCheckpoint('best_model.h5', monitor='val_loss', mode='min', verbose=1, save_best_only=True)

model.summary()

#train model

history = model.fit(trainX, train_y, epochs=1000, verbose=1, validation_split=0.33, callbacks=[earlyStop], shuffle=False)

#test model

test_predict = model.predict(testX, verbose=1)
print(test_predict)

#invert value

predictedTest = scaler.inverse_transform(test_predict)
testY = scaler.inverse_transform(test_y)
trainY = scaler.inverse_transform(train_y)

#reshape array to 1d array

trainY = trainY.flatten()
testY = testY.flatten()
predictedTest = predictedTest.flatten()

#calculate MSE
mse = mean_squared_error(testY,predictedTest, squared=False)
print(mse)

#loss visualization in training and validation
# summarize history for loss

plt.plot(history.history['loss'])
plt.plot(history.history['val_loss'])
plt.title('model loss')
plt.ylabel('loss')
plt.xlabel('epoch')
plt.legend(['train', 'test'], loc='upper left')
plt.show()

#convert string to datetime

def to_datetime(test_date):
  test_datetime = []
  for i in range(len(test_date)):
    date = datetime.datetime.strptime(test_date[i], "%Y.%m.%d%H:%M")
    test_datetime.append(date)
  return test_datetime

test_datetime = to_datetime(test_date)

#visualize data

plt.figure(figsize=[25,15])
plt.title('1-hour timeframe 2020 Prediction Result')
plt.ylabel('Close Price')
plt.xlabel('Date')
plt.plot(test_datetime, testY)
plt.plot(test_datetime, predictedTest)
plt.legend(['true', 'predict'], loc='upper right')
plt.show()

